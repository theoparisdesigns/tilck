#!/usr/bin/env python3
# SPDX-License-Identifier: BSD-2-Clause

import os
import sys
import urllib.request

PCI_IDS_URL = r'https://github.com/pciutils/pciids/blob/master/pci.ids?raw=true'
FIXED_COMMENTS = '''
/*
 * List of PCI IDs generated by scripts/dev/generate_pci_ids, part of the
 * Tilck project.
 *
 * Source data fetched from the `pciids` project:
 *    {}
 *
 * Follows the original comments from the top of the `pci.ids` file.
 *'''.format(PCI_IDS_URL)

textdata = ''

def download_pci_ids_from_github():
   response = urllib.request.urlopen(PCI_IDS_URL)
   return response.read().decode('utf-8')

def show_help_and_exit():
   print("Options:")
   print("     -v [pci_ids_file]  Generate vendors C file")
   print("     -c [pci_ids_file]  Generate device classes C file")
   sys.exit(1)

def dump_initial_comments():

   print(FIXED_COMMENTS)

   for line in textdata:

      if not line or line[0] != '#':
         break

      text = line[1:].strip()

      if text:
         print(" *    {}".format(text))
      else:
         print(" *")

   print(" */")
   print("")
   print(r"#include <tilck/kernel/pci.h>")
   print("")

def generate_vendors():

   # Minimal escape strings for C. Yes, there's a vendor with "" in the name.
   transl = str.maketrans({r'"': r'\"'})

   print("const struct pci_vendor pci_vendors_list[] =")
   print("{")

   for line in textdata:

      if not line or line[0] == '#':
         continue

      if line[0].isspace():
         continue # That's a device (1 tab) or sub-vendor + subdevice (2 tabs)

      if line[0] == 'C':
         break # That's a device class: we have to stop

      devid = int(line[0:4], base=16)
      name = line[4:].strip().translate(transl).replace("???", "?")
      print("   {{ 0x{:04x}, \"{}\" }},".format(devid, name))

   print("};")
   print("")

def str_or_NULL(val):
   return '"{}"'.format(val) if val else "NULL"

class device_class_ctx:

   def __init__(self,
                class_id = 0,
                subclass_id = 0,
                progif_id = 0,
                class_name = "",
                subclass_name = "",
                progif_name = ""):

      self.class_id = class_id
      self.subclass_id = subclass_id
      self.progif_id = progif_id
      self.class_name = class_name
      self.subclass_name = subclass_name
      self.progif_name = progif_name

   def set_class(self, class_id, class_name):

      self.class_id = class_id
      self.class_name = class_name

      # Reset the subclass and progid fields
      self.subclass_id = 0
      self.progif_id = 0
      self.subclass_name = ""
      self.progif_name = ""

   def set_subclass(self, subclass_id, subclass_name):

      self.subclass_id = subclass_id
      self.subclass_name = subclass_name

      # Reset the progif fields
      self.progif_id = 0
      self.progif_name = ""

   def set_progif(self, progif_id, progif_name):

      self.progif_id = progif_id
      self.progif_name = progif_name

   def dump(self):
      print("   {{ 0x{:02x}, 0x{:02x}, 0x{:02x}, {}, {}, {} }},"
               .format(self.class_id,
                       self.subclass_id,
                       self.progif_id,
                       str_or_NULL(self.class_name),
                       str_or_NULL(self.subclass_name),
                       str_or_NULL(self.progif_name)))


def generate_device_classes():

   dev_classes = False

   print("const struct pci_device_class pci_device_classes_list[] =")
   print("{")

   devclass = device_class_ctx()
   class_dumped = True
   subclass_dumped = True

   for line in textdata:

      if not line or line[0] == '#':
         continue

      if not dev_classes:

         if line[0] != 'C':
            continue # Device classes haven't started yet

         # This is the first device class in the file
         dev_classes = True

      # We're for sure parsing the "device classes" part of the file

      if line[0] == 'C':

         # New device class
         new_class_id = int(line[2:4], base=16)
         new_class_name = line[4:].strip()

         if not class_dumped or not subclass_dumped:
            # The previous class was not dumped and it had no subclass
            devclass.dump()

         devclass.set_class(new_class_id, new_class_name)

         # We just hit a new class. Of course, we haven't dumped it yet:
         # set class_dumped to False and reset subclass_dumped.
         # Note: resetting the *_dumped vars means setting them to True
         class_dumped = False
         subclass_dumped = True

      elif line[0].isspace() and not line[1].isspace():

         # New device sub-class
         new_subclass_id = int(line[1:3], base=16)
         new_subclass_name = line[4:].strip()

         if not subclass_dumped:
            # The previous sub-class was not dumped and it had no progif
            devclass.dump()
            class_dumped = True

         devclass.set_subclass(new_subclass_id, new_subclass_name)
         subclass_dumped = False

      else:

         # Device programming interface (sub-sub-class)
         new_progif_id = int(line[2:4], base=16)
         new_progif_name = line[5:].strip()
         devclass.set_progif(new_progif_id, new_progif_name)

         devclass.dump()
         class_dumped = True
         subclass_dumped = True


   if not class_dumped or not subclass_dumped:
      devclass.dump()

   print("};")
   print("")


def main():

   global textdata

   if len(sys.argv) < 2:
      show_help_and_exit()

   if sys.argv[1] not in ["-v", "-c"]:
      show_help_and_exit()

   if len(sys.argv) > 2:
      with open(sys.argv[2], 'r') as fh:
         blob = fh.read()
   else:
      blob = download_pci_ids_from_github()

   textdata = blob.splitlines()
   dump_initial_comments()

   if sys.argv[1] == '-v':
      generate_vendors()
   elif sys.argv[1] == '-c':
      generate_device_classes()

if __name__ == '__main__':
   main()
